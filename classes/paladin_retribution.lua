local _,Analyzer=...if not Analyzer then return end
local module={}
local utils=Analyzer.utils
module.name="Paladin - Retribution"
module.class="PALADIN"
module.specKey="retribution"
module.specIndex=3
module.specId=70
local SPELL_TEMPLAR_VERDICT=85256
local SPELL_CRUSADER_STRIKE=35395
local SPELL_JUDGMENT=20271
local SPELL_EXORCISM=879
local SPELL_HAMMER_OF_WRATH=24275
local SPELL_INQUISITION=84963
local SPELL_AVENGING_WRATH=31884
local SPELL_GUARDIAN_OF_ANCIENT_KINGS=86150
local SPELL_EXECUTION_SENTENCE=114157
local SPELL_HOLY_AVENGER=105809
local SPELL_ART_OF_WAR=59578
local SPELL_DIVINE_PURPOSE=90174
local COOLDOWN_AVENGING_WRATH=180
local COOLDOWN_GUARDIAN=300
local SOUND_KEY_ART_OF_WAR="artOfWar"
local SOUND_KEY_DIVINE_PURPOSE="divinePurpose"
local TRACKED_BUFFS={[SPELL_INQUISITION]=true,[SPELL_AVENGING_WRATH]=true,[SPELL_GUARDIAN_OF_ANCIENT_KINGS]=true,[SPELL_ART_OF_WAR]=true,[SPELL_DIVINE_PURPOSE]=true}
local TRACKED_DEBUFFS={}
local TRACKED_CASTS={[SPELL_TEMPLAR_VERDICT]=true,[SPELL_CRUSADER_STRIKE]=true,[SPELL_JUDGMENT]=true,[SPELL_EXORCISM]=true,[SPELL_HAMMER_OF_WRATH]=true,[SPELL_INQUISITION]=true}
local function EnsureHistory(c,s)c[s]=c[s]or{}return c[s]end
function module.SupportsSpec(a)if a.player.class~=module.class then return false end if a.player.specId==module.specId then return true end local sk=utils.NormalizeSpecKey(a.player.specName)if sk==module.specKey then return true end if a.player.specIndex==module.specIndex then return true end return false end
function module.OnPlayerInit(a)if a.player.class~=module.class then return end if a.player.specName~="Unknown"then return end if IsSpellKnown and IsSpellKnown(SPELL_TEMPLAR_VERDICT)then a.player.specName="Retribution"a.player.specId=a.player.specId or module.specId a.player.specIndex=a.player.specIndex or module.specIndex end end
function module.GetDefaultSettings()return{sounds={[SOUND_KEY_ART_OF_WAR]={enabled=true,sound="Sound\\Interface\\RaidWarning.ogg"},[SOUND_KEY_DIVINE_PURPOSE]={enabled=true,sound="Sound\\Interface\\MapPing.ogg"}}}end
function module.GetSoundOptions()return{{key=SOUND_KEY_ART_OF_WAR,label="Art of War"},{key=SOUND_KEY_DIVINE_PURPOSE,label="Divine Purpose"}}end
function module.IsTrackedBuffSpell(s)return TRACKED_BUFFS[s]==true end
function module.IsTrackedDebuffSpell(s)return TRACKED_DEBUFFS[s]==true end
function module.IsTrackedCast(s)return TRACKED_CASTS[s]==true end
function module.ShouldRecordCast(e)if not e or not e.spellId then return false end return TRACKED_CASTS[e.spellId]==true end
function module.GetProcInfo(s)if s==SPELL_ART_OF_WAR then return{soundKey=SOUND_KEY_ART_OF_WAR,priority=2}elseif s==SPELL_DIVINE_PURPOSE then return{soundKey=SOUND_KEY_DIVINE_PURPOSE,priority=3}end return nil end
function module.InitFight(_,f)f.procs={artOfWarProcs=0,artOfWarConsumed=0,divinePurposeProcs=0}f.cooldowns={avengingWrathLast=0,guardianLast=0}f.castLog={}f.buffHistory={}f.debuffHistory={}f.rotation={totalCasts=0,optimalCasts=0,suboptimalCasts=0,mistakes={},penaltySum=0}end
function module.TrackSpellCast(a,s,t)local f=a.fight if not f or not TRACKED_CASTS[s]then return end local n=utils.NormalizeTimestamp(t)f.spells[s]=(f.spells[s]or 0)+1 table.insert(f.castLog,{spellId=s,timestamp=n})if s==SPELL_EXORCISM then local b=f.buffs[SPELL_ART_OF_WAR]if b and(b.stacks or 0)>0 then f.procs.artOfWarConsumed=f.procs.artOfWarConsumed+1 b.consumed=true b.stacks=0 end elseif s==SPELL_AVENGING_WRATH then f.cooldowns.avengingWrathLast=n a:AddTimelineEvent(s,n,"cooldown")a:AddEventLog(n,"Avenging Wrath",s)elseif s==SPELL_GUARDIAN_OF_ANCIENT_KINGS then f.cooldowns.guardianLast=n a:AddTimelineEvent(s,n,"cooldown")a:AddEventLog(n,"Guardian",s)end local cS={[SPELL_TEMPLAR_VERDICT]=true,[SPELL_CRUSADER_STRIKE]=true,[SPELL_JUDGMENT]=true,[SPELL_EXORCISM]=true,[SPELL_HAMMER_OF_WRATH]=true,[SPELL_INQUISITION]=true}if cS[s]and f.rotation then local ev=module.EvaluateCast(a,f,s,n)if ev then module.RecordCastEvaluation(f,ev,n)end end end
function module.TrackAura(a,se,s,am,t)local f=a.fight if not f then return end local n=utils.NormalizeTimestamp(t)if se=="SPELL_AURA_APPLIED"or se=="SPELL_AURA_APPLIED_DOSE"or se=="SPELL_AURA_REFRESH"then local st=am or 1 local b=f.buffs[s]local isR=(se=="SPELL_AURA_REFRESH")if b and isR and b.since then f.buffUptime[s]=(f.buffUptime[s]or 0)+(n-b.since)end if not b then b={stacks=st,since=n}f.buffs[s]=b else b.stacks=st b.since=b.since or n end if isR then b.since=n end local h=EnsureHistory(f.buffHistory,s)if isR and b.historyEntry and not b.historyEntry.removed then b.historyEntry.removed=n end if not b.historyEntry or isR then b.historyEntry={applied=n}table.insert(h,b.historyEntry)end if s==SPELL_ART_OF_WAR then if not isR then f.procs.artOfWarProcs=f.procs.artOfWarProcs+1 a:AddTimelineEvent(s,n,"proc")a:AddEventLog(n,"Art of War proc",s)end a:PlayAlertSound(SOUND_KEY_ART_OF_WAR,n)elseif s==SPELL_DIVINE_PURPOSE then if not isR then f.procs.divinePurposeProcs=f.procs.divinePurposeProcs+1 a:AddTimelineEvent(s,n,"proc")a:AddEventLog(n,"Divine Purpose proc",s)end a:PlayAlertSound(SOUND_KEY_DIVINE_PURPOSE,n)end elseif se=="SPELL_AURA_REMOVED"then local b=f.buffs[s]if b then if b.since then f.buffUptime[s]=(f.buffUptime[s]or 0)+(n-b.since)end if b.historyEntry and not b.historyEntry.removed then b.historyEntry.removed=n end end f.buffs[s]=nil end end
function module.Analyze(a,f,c)local m={}local i={}local sc=100 if c.duration<15 then utils.AddIssue(i,"Walka zbyt krotka.")return{score=0,metrics=m,issues=i}end local function AM(l,s,v,p,st,it,pen)table.insert(m,{label=l,spellId=s,valueText=v or"",percent=p,status=st or"info"})utils.AddIssue(i,it)if pen and pen>0 then sc=utils.Clamp(sc-pen,0,100)end end local inqUp=utils.SafePercent(f.buffUptime[SPELL_INQUISITION]or 0,c.duration)local inqSt=utils.StatusForPercent(inqUp,0.90,0.75)AM("Inquisition uptime",SPELL_INQUISITION,utils.FormatPercent(inqUp),inqUp,inqSt,inqSt=="bad"and"Niski uptime Inquisition."or(inqSt=="warn"and"Inquisition moglby byc wyzszy."or nil),inqSt=="bad"and 15 or(inqSt=="warn"and 8 or 0))local aow=f.procs.artOfWarProcs or 0 local aowC=f.procs.artOfWarConsumed or 0 if aow>0 then local aowU=utils.SafePercent(aowC,aow)local aowSt=utils.StatusForPercent(aowU,0.85,0.70)AM("Art of War wykorzystanie",SPELL_ART_OF_WAR,string.format("%s (%d/%d)",utils.FormatPercent(aowU),aowC,aow),aowU,aowSt,aowSt=="bad"and"Za duzo AoW nie zuzyte."or(aowSt=="warn"and"Czesc AoW sie marnuje."or nil),aowSt=="bad"and 10 or(aowSt=="warn"and 5 or 0))end local aw=f.spells[SPELL_AVENGING_WRATH]or 0 local expAW=utils.ExpectedUses(c.duration,COOLDOWN_AVENGING_WRATH,10)if expAW>0 then local awP=utils.SafePercent(aw,expAW)local awSt=utils.StatusForPercent(awP,1.0,0.7)AM("Avenging Wrath uzycia",SPELL_AVENGING_WRATH,string.format("%d/%d",aw,expAW),math.min(awP or 0,1),awSt,aw<expAW and"Za malo AW."or nil,aw<expAW and 8 or 0)end if f.rotation and f.rotation.totalCasts>0 then local rS=module.GetRotationScore(f)if rS then local rA=rS.accuracy or 0 local rSt=utils.StatusForPercent(rA,0.85,0.70)AM("Dokladnosc rotacji (APL)",nil,string.format("%.0f%% (%d/%d)",rA*100,rS.optimalCasts,rS.totalCasts),rA,rSt,rSt=="bad"and"Niska dokladnosc."or(rSt=="warn"and"Srednia dokladnosc."or nil),rSt=="bad"and 10 or(rSt=="warn"and 5 or 0))if rS.mistakes and #rS.mistakes>0 then local mC={}for _,mk in ipairs(rS.mistakes)do mC[mk.reason or"Unknown"]=(mC[mk.reason or"Unknown"]or 0)+1 end local sM={}for r,ct in pairs(mC)do table.insert(sM,{reason=r,count=ct})end table.sort(sM,function(x,y)return x.count>y.count end)for j=1,math.min(3,#sM)do local mk=sM[j]if mk.count>=2 then utils.AddIssue(i,string.format("Blad rotacji (%dx): %s",mk.count,mk.reason))end end end end end sc=utils.Clamp(sc,0,100)return{score=sc,metrics=m,issues=i}end
function module.GetLiveScore(a,f)if not f then return nil end local n=GetTime()local d=n-f.startTime if d<5 then return nil end return 100 end
local function CPB(s)if not s then return false end for i=1,40 do local _,_,_,_,_,_,_,_,_,aS=UnitBuff("player",i)if not aS then break end if aS==s then return true end end return false end
local function GetHolyPower()if UnitPower then return UnitPower("player",9)end return 0 end
function module.GetLiveAdvice(a,f)if not f then return""end local n=GetTime()local d=n-f.startTime local hasAoW=CPB(SPELL_ART_OF_WAR)if hasAoW then return"Art of War! Exorcism!"end local hp=GetHolyPower()if hp>=3 and not CPB(SPELL_INQUISITION)and d>5 then return"Uzyj Inquisition (3 HP)!"end if hp>=5 then return"5 Holy Power! Templar's Verdict!"end if utils.IsSpellReady(SPELL_AVENGING_WRATH)and d>15 then return"Avenging Wrath gotowe!"end if utils.IsSpellReady(SPELL_CRUSADER_STRIKE)then return"Crusader Strike gotowy!"end return""end
function module.GetAdviceSpellIcon(a,f)if not f then return nil end local n=GetTime()local d=n-f.startTime local hasAoW=CPB(SPELL_ART_OF_WAR)if hasAoW then return SPELL_EXORCISM end local hp=GetHolyPower()if hp>=3 and not CPB(SPELL_INQUISITION)and d>5 then return SPELL_INQUISITION end if hp>=5 then return SPELL_TEMPLAR_VERDICT end if utils.IsSpellReady(SPELL_AVENGING_WRATH)and d>15 then return SPELL_AVENGING_WRATH end if utils.IsSpellReady(SPELL_CRUSADER_STRIKE)then return SPELL_CRUSADER_STRIKE end return nil end
local APL_PRIORITY={{id="aw",spellId=SPELL_AVENGING_WRATH,name="Avenging Wrath",condition=function(s)return s.awReady and s.duration>10 end,priority=1,category="cooldown"},{id="inq_missing",spellId=SPELL_INQUISITION,name="Inquisition",condition=function(s)return s.holyPower>=3 and not s.inqActive and s.duration>5 end,priority=2,category="buff"},{id="exo_aow",spellId=SPELL_EXORCISM,name="Exorcism(AoW)",condition=function(s)return s.artOfWarActive end,priority=3,category="proc"},{id="tv_5hp",spellId=SPELL_TEMPLAR_VERDICT,name="TV(5HP)",condition=function(s)return s.holyPower>=5 end,priority=4,category="damage"},{id="how",spellId=SPELL_HAMMER_OF_WRATH,name="Hammer of Wrath",condition=function(s)return s.howReady end,priority=5,category="damage"},{id="cs",spellId=SPELL_CRUSADER_STRIKE,name="Crusader Strike",condition=function(s)return s.csReady end,priority=6,category="builder"},{id="judge",spellId=SPELL_JUDGMENT,name="Judgment",condition=function(s)return s.judgeReady end,priority=7,category="builder"},{id="tv_3hp",spellId=SPELL_TEMPLAR_VERDICT,name="TV(3HP)",condition=function(s)return s.holyPower>=3 end,priority=8,category="damage"},{id="exo",spellId=SPELL_EXORCISM,name="Exorcism",condition=function(s)return s.exoReady end,priority=9,category="filler"}}
local function GCS(a,f)local s={duration=0,holyPower=0,artOfWarActive=false,inqActive=false,awReady=false,csReady=false,judgeReady=false,howReady=false,exoReady=false}if not f then return s end local n=GetTime()s.duration=n-(f.startTime or n)s.holyPower=GetHolyPower()s.artOfWarActive=CPB(SPELL_ART_OF_WAR)s.inqActive=CPB(SPELL_INQUISITION)s.awReady=utils.IsSpellReady(SPELL_AVENGING_WRATH)s.csReady=utils.IsSpellReady(SPELL_CRUSADER_STRIKE)s.judgeReady=utils.IsSpellReady(SPELL_JUDGMENT)s.howReady=utils.IsSpellReady(SPELL_HAMMER_OF_WRATH)s.exoReady=utils.IsSpellReady(SPELL_EXORCISM)return s end
function module.GetNextAPLAction(a,f)local s=GCS(a,f)for _,act in ipairs(APL_PRIORITY)do if act.condition(s)then return act end end return APL_PRIORITY[#APL_PRIORITY]end
function module.GetAPLPriorityList()return APL_PRIORITY end
function module.GetRotationState(a,f)return GCS(a,f)end
function module.EvaluateCast(a,f,sid,ts)local nA=module.GetNextAPLAction(a,f)if not nA then return nil end local isO=(nA.spellId==sid)local pen=0 local rsn=""if not isO then local cP=nil for _,act in ipairs(APL_PRIORITY)do if act.spellId==sid then cP=act.priority break end end if cP then pen=math.abs(nA.priority-cP)*2 rsn=string.format("Powinienes: %s",nA.name)else pen=5 rsn="Spell poza APL"end end return{isOptimal=isO,penalty=pen,reason=rsn,expectedSpell=nA.spellId,expectedName=nA.name,actualSpell=sid}end
function module.RecordCastEvaluation(f,ev,ts)if not f.rotation then return end f.rotation.totalCasts=f.rotation.totalCasts+1 if ev.isOptimal then f.rotation.optimalCasts=f.rotation.optimalCasts+1 else f.rotation.suboptimalCasts=f.rotation.suboptimalCasts+1 f.rotation.penaltySum=f.rotation.penaltySum+ev.penalty table.insert(f.rotation.mistakes,{timestamp=ts,reason=ev.reason,penalty=ev.penalty,expected=ev.expectedName})end end
function module.GetRotationScore(f)if not f.rotation or f.rotation.totalCasts==0 then return nil end return{accuracy=f.rotation.optimalCasts/f.rotation.totalCasts,totalCasts=f.rotation.totalCasts,optimalCasts=f.rotation.optimalCasts,suboptimalCasts=f.rotation.suboptimalCasts,mistakes=f.rotation.mistakes,penaltySum=f.rotation.penaltySum}end
Analyzer:RegisterClassModule(module.class,module)
